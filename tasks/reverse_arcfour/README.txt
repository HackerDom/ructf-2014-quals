Таск из 2 частей:
	Сам крякми с несколькими трюками по антиотладке
	Он упакован upx, в который вшит tls. TLS модифицирует код распаковщика upx так, что тот перед прыжком на OEP модифицирует в уже распакованном образе несколько байт.
	Если юзер сделает `upx -d`, то TLS исчезнет и будет твориться мясо.

Для начала сам crackme, еще не тронутый upx'ом.
Юзер должен ввести пароль первым параметром командной строки (этот пароль и является флагом).
argv[1] присваивается глобальному указателю user_pass (чтобы check_pass не имел параметров => меньше байт займет его вызов).
После этого инициализируется SEH.
	Upx в tls делает так, чтобы на месте 2 нопов был ud2 => сработал бы SEH.
	без upx код выдаст фейк.
SEH не показывается в графовом моде IDA v5 (с v6 норм), а так же OllyDbg не передает управление обработчику исключения.
В обработчике исключения идет asm мясо. Смысл его:
1) в eax ложится 0xD11E3A ^ 0x910EEA == 0x4010D0 - адрес check_pass
2) jz гарантированно не срабатывает
3) на стек ложится lbl_call_eax + 3
4) ret прыгает по lbl_call_eax + 3. т.е прыгает в середину инструкции `mov eax, 0xD0FF5B21`, и выполняется на самом деле `FF D0` == call eax
Функция check_pass:
Через стэк загоняется эталон закриптованного флага и ключ.
В переменную BeingDebugged мясным образом ложится байт из соответствующего поля в PEB.
key ксорится с этим байтом. В итоге возможны следующие ситуации:
	- без upx и без отладчика BeingDebugged == 0
	- без upx и с отладчиком BeingDebugged == 1
	- с upx и без отладчика BeingDebugged == 0xb6 - и получается правильный ключ
	- с upx и с отладчиком BeingDebugged == 0xb7
user_pass шифруется по rc4 (поэтому таскнейм arcfour) и проверяется с эталоном.

Часть с upx:
Я сжал откомпиленный файл (причем компилировал без релоков и ASLR, enable c++ exception = no), вручную в hex editor добавил на место нулей в конце секции опкоды.

Как решать?
Вначале понять, что что-то тут неладное, нопы тут не зря, и upx наверно тоже, увидеть для чего нужен upx.
Сквозь тернии понять, что тут ксор ключа с BeingDebugged, и rc4 от введенного пароля.
flag = rc4(crypted_flag, key ^ BeingDebugged)