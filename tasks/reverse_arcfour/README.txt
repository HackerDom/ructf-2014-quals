Таск из 2 частей:
1) Сам крякми с несколькими трюками по антиотладке
2) Он упакован upx, в который вшит tls. TLS модифицирует код распаковщика upx так, что тот перед прыжком на OEP модифицирует в уже распакованном образе несколько байт. Если юзер сделает `upx -d`, то TLS исчезнет и будет твориться мясо.

Как работает сам crackme:
Пароль вводится параметром командной строки (этот пароль и является флагом).
argv[1] присваивается глобальному указателю user_pass.
Инициализируется SEH.
	Upx в tls делает так, чтобы на месте 2 нопов был ud2 => гарантированно сработал обработчик.
	Без upx код выдаст фейк.
SEH не показывается в графовом моде IDA v5 (v6 показывает), а так же OllyDbg не передает управление обработчику исключения.
В обработчике исключения идет asm мясо. Смысл его:
1) в eax ложится 0xD11E3A ^ 0x910EEA == 0x4010D0 - адрес check_pass
2) jz гарантированно не срабатывает
3) на стек ложится lbl_call_eax + 3
4) ret прыгает по lbl_call_eax + 3. т.е прыгает в середину инструкции `mov eax, 0xD0FF5B21`, и выполняется на самом деле `FF D0` == call eax
Функция check_pass:
В стэке получаем эталон закриптованного флага и ключ.
В переменную BeingDebugged мясным образом ложится байт из соответствующего поля в PEB.
key ксорится с этим байтом. В итоге возможны следующие ситуации:
	- без upx и без отладчика BeingDebugged == 0
	- без upx и с отладчиком BeingDebugged == 1
	- с upx и без отладчика BeingDebugged == 0xb6 - и получается правильный ключ
	- с upx и с отладчиком BeingDebugged == 0xb7
user_pass шифруется по rc4 (поэтому таскнейм arcfour) и проверяется с эталоном.

Часть с upx:
Я сжал откомпиленный файл (причем компилировал без релоков и ASLR, enable c++ exception = no), вручную в hex editor добавил на место нулей в конце секции опкоды.

Как решать?
Вначале понять, что что-то тут неладное, нопы тут не зря, и upx наверно тоже, увидеть для чего нужен upx.
Сквозь тернии понять, что тут ксор ключа с BeingDebugged, и rc4 от введенного пароля.
flag = rc4(crypted_flag, key ^ BeingDebugged)